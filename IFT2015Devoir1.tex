\documentclass[9pt]{report}
%\usepackage[utopia]{mathdesign} 

\usepackage{amsmath,amsfonts,amsthm,amssymb,mathtools}
%\usepackage{amsmath,amsthm,mathtools}
%\usepackage{libertine}
\input{preamble.tex}
\usepackage[scr]{rsfso}


\lstset{basicstyle=\ttfamily}
%\usepackage[euler-digits]{eulervm}
\usepackage{mathpazo}
%usepackage{palatino}
%usepackage{crimson}


\title{\Huge{Structures de Données}\\{IFT2015}\\{\textbf{Devoir 1}}}
\author{\huge{Franz Girardin}}
\date{\today}
\lstset{inputencoding=utf8/latin1}






            %%%%%%%%%%%%%%%%%  Sect.                          %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{helvet}
\titleformat{\chapter}
  {\fontfamily{}\bfseries\huge} % format
  {}                % label
  {0pt}             % sep
  {\color{myb}\huge}           % before-code



\titleformat{\section}
  {\normalfont\scshape}{\thesection}{1em}{}


% Customizing the spacing for the chapter titles
\titlespacing*{\chapter}{0pt}{0pt}{20pt}

% Allow hfill in math environment
\newcommand{\specialcell}[1]{\ifmeasuring@#1\else\omit$\displaystyle#1$\ignorespaces\fi}

% Allow you to do the non implication (implication barred)
\newcommand{\notimplies}{%
  \mathrel{{\ooalign{\hidewidth$\not\phantom{=}$\hidewidth\cr$\implies$}}}}



\DeclareRobustCommand{\looongrightarrow}{%
  \DOTSB\relbar\joinrel\relbar\joinrel\relbar\joinrel\rightarrow
}


\DeclareMathOperator{\di}{d\!}
\newcommand*\Eval[3]{\left.#1\right\rvert_{#2}^{#3}}

\begin{document}
\maketitle

\pagebreak
\tableofcontents
\pagebreak


\chapter{Analyse de complexité}
  \vspace{-2em}
\begin{multicols*}{2}
  \small
  \begin{Exercice}{}{}
    Compte tenu des fonctions mystérieuses suivantes, pour chacune d’elles, 
    déterminer quelle est la complexité dans le temps et l’espace de son exécution 
    (Big O) et expliquer ce que vous pensez que la fonction fait. Les réponses 
    simples ne seront pas acceptées, il est nécessaire de justifier votre réponse.
    Par exemple : Si dans l’exercice la récursion est utilisée, vous pouvez 
    soutenir votre justification en présentant l’arbre de récursion. 
    Toutes vos réponses doivent être incluses dans votre rapport.
  \end{Exercice}
  \section{\texttt{MistFonction1}}
  \vspace{-1em}

  \begin{lstlisting}[style=JavaDraculaWhite]
public class MistFonction1{

  public static int mistFonction1(int m, int n) {
      if (m == 1) && (n == 1) return 1; 
      if (m == 0) || (n == 0) return 0
      return mistFonction1(m -1, n) + mistFonction1(m, n -1)
  }
}\end{lstlisting}
  \vspace{-1em}

  \paragraph{}
  La fonction présente deux \textbf{cas de bases}, dont l'un retourne la valeur 
  \texttt{1} lorsque \textit{les deux} arguments ont pour valeur $1$, alors que 
  l'autre retourne $0$ sous la condition que \textit{l'un des deux} arguments 
    a pour valur $0$. 

  \paragraph{}
  La seconde portion de la fonction engendre des appels récursifs 
  qui prennent fin lorsque les cas de bases sont rencontré. Nous constatons 
  alors que chaque appel de fonction \textit{hors base} engendre 
  \textbf{deux appels}, jusqu'à ce que les conditions d'arrêts soient effectives. 
  
  \begin{figure}[H]
    \scriptsize
 \dirtree{%
.1 f(3, 3) $\rightarrow$ \textcolor{blue}{3} + \textcolor{blue}{3} =    \textcolor{red}{6}.
.2 f(2, 3) $\rightarrow$ \textcolor{blue}{3}.
.3 f(1, 3)  $\rightarrow$ \textcolor{myg}{1}.
.4 f(0, 3) $\rightarrow$ 0 \textit{cas de base}.
.4 f(1, 2) $\rightarrow$ \textcolor{myg}{1}  .
.5 f(0, 2) $\rightarrow$ 0 \textit{cas de base}.
.5 f(1, 1) $\rightarrow$ 1 \textit{cas de base}.
.3 f(2, 2) $\rightarrow$ \textcolor{myg}{2}.
.4 f(1, 2) $\rightarrow$ \textcolor{myg}{1} (répète le sous-arbre ci-dessus).
.4 f(2, 1) $\rightarrow$ \textcolor{myg}{1}.
.5 f(1, 1) $\rightarrow$ 1 \textit{cas de base}.
.5 f(2, 0) $\rightarrow$ 0 \textit{cas de base}.
.2 f(3, 2) $\rightarrow$ \textcolor{blue}{3} .
.3 f(2, 2) $\rightarrow$ \textcolor{myg}{2} (répète le sous-arbre ci-dessus).
.4 f(1, 2) (répète le sous-arbre ci-dessus).
.4 f(2, 1) (répète le sous-arbre ci-dessus).
.3 f(3, 1) $\rightarrow$ \textcolor{myg}{1}.
.4 f(2, 1) (répète le sous-arbre ci-dessus).
.4 f(3, 0)  $\rightarrow$ 0 \textit{cas de base}  .
}
\caption{Exemple de $f(3,3)$}
  \end{figure}
  \paragraph{}
  Ainsi, nous pouvons représenter 
  les appels récursifs par une arbre tel qu'à chaque 
  niveau de l'arbre, \textbf{le nombre d'appels est doublé} 
  par rapport au précédent.
  En considérant $j$ comme étant la valeur de $m$ lorsque $m$ atteint $0$, 
  et $k$, la valeur de $n$ lorsque $n$ atteint $1$, on obtient 
  l'arbre généralisé à tous les cas possibles qui est présenté à la figure 1.2. 



  \vspace{-1em}
  \begin{figure}[H]
          \scriptsize


     
    \dirtree{%
  .1 f(m, n).
  .2 f(m-1, n).
  .3 f(m-2, n).
  .4 $\vdots$.
  .5 f(j+1, n).
  .6 f(j, n) $\rightarrow$ 0 \textit{cas de base}.
  .6 f(j+1, n-1).
  .7 $\vdots$.
  .8 f(j+1, k+1).
  .9 f(j, k+1) $\rightarrow$ 0 \textit{cas de base}.
  .9 f(j+1, k) $\rightarrow$  \textit{cas de base}.
  .8 f(j+1, k) $\rightarrow$  \textit{cas de base}.
  .3 f(m-1, n-1).
  .4 $\vdots$.
  .2 f(m, n-1).
  .3 f(m-1, n-1).
  .4 $\vdots$.
  .5 f(j+1, n-1).
  .6 f(j, n-1) $\rightarrow$ 0 \textit{cas de base}.
  .6 f(j+1, n-2).
  .7 $\vdots$.
  .8 f(j+1, k+1).
  .9 f(j, k+1) $\rightarrow$ 0 \textit{cas de base}.
  .9 f(j+1, k) $\rightarrow$  \textit{cas de base}.
  .8 f(j+1, k) $\rightarrow$  \textit{cas de base}.
  .3 f(m, n-2).
  .4 $\vdots$.
  }
  \caption{Stucture arboressante de la fonction}
  \end{figure}

  \paragraph{Complexité dans le temps}
  \mbox{}\\
  La complexité temporelle de cette fonction est \textit{exponentielle}, puisqu'à 
  chaque appel récursif, deux nouveaux appels sont engendrés. Par ailleurs, 
  chaque argument $m$ et $n$ peut augmenter la complexité. Nous avons donc : 
  \[ O( m +n )^2 \]

  \begin{note}{}{}
      L'arbre est \textbf{symétrique} : 
      \[ \forall n, m \in \mathbb{N}, f(m, n) = f(n, m) \]   
      Nous avons d'ailleur montré que $f(3, 2) = f(2, 3)$
  \end{note}        
  \begin{figure*}
   \begin{lstlisting}[style=JavaDraculaWhite]
 public class MistFunction2 {
    public static List<List<String>> mistFunction2(String target, List<String> pieces) {
        List<List<String>>[] table = new ArrayList[target.length() + 1];
        for (int i = 0; i <= target.length(); i++) {
            table[i] = new ArrayList<>();
        }
        table[0].add(new ArrayList<>());

        for (int i = 0; i < target.length(); i++) {
            for (String piece : pieces) {
                if (i + piece.length() <= target.length() &&
                    target.startsWith(piece, i)) {
                    List<List<String>> newCombinations = new ArrayList<>();
                    for (List<String> subarray : table[i]) {
                        List<String> newSubarray = new ArrayList<>(subarray);
                        newSubarray.add(piece);
                        newCombinations.add(newSubarray);
                    }
                    table[i + piece.length()].addAll(newCombinations);
                }
            }
        }

        return table[target.length()];
    }
}
    
  \end{lstlisting}    
  \end{figure*}
  \paragraph{Complexité dans l'espace}
  \mbox{}\\
  Chaque appel résursif est additionné dans 
  \textbf{la pile d'appels} qui emmagasine en mémoire 
  quelles fonctions parents sont appelées par les fonction enfants. 
  La complexité dans l'espace correspond donc à la hateur de la pile d'appel 
  qui est elle-même liée à la profondeur maximale de l'arbre. 


  
  La profondeur maximale de l'arbre correspond 
  au chemin le plus long de la racine de l'arbre d'appels (lorsque f(m, n) 
  est appelé pour la première fois) jusqu'à une feuille de l'arbre 
  (lorsque une condition de base est atteinte). 
  Dans ce cas, la profondeur maximale est atteinte lorsqu'on 
  suit toujours le chemin $f(m - 1, n)  $ou $f(m, n - 1)$ jusqu'à
  ce que m ou n atteigne 0. Si $m \neq n$, l'une des deux direction sera plus longue. 
  Il faut donc considérer $\max(m, n)$. 

  On peut alors conclure que la complexité
  en espace de cet algorithme est : 
  \[ O(\max(m, n)) \]


  \paragraph{Raison dêtre}
  L'algorithme semble compter le nombre de façons possibles de se déplacer 
  dans une grille $m \times n$ avec comme contrainte de se déplacer uniquement 
  vers le bas ($m$) ou uniquement vers la drotie $(n)$
  \section{\texttt{MistFunction2}} 
  \paragraph{Raison d'être}
  Soit une chaine de caractères \texttt{target} et une liste 
  \texttt{pieces} dont chaque élément est un caractère de  
  la chaîne \texttt{target}, la fonction engendre une 
  liste de listes de chaînes de charactère. Cette liste correspond 
  à \textit{toutes les combinaisons possibles} de caractères permmetant 
  d'obtenir la chaîne originale. 

  \begin{EExample}{}{}
    Soit \texttt{target = "abc"} et \texttt{piece = ["a", "b", "c"]}, on obtient 
    alors le résultat suivant : 
    \begin{itemize}
      \item [$\rhd$] \texttt{table = } \textcolor{red}{[}
        \\ \texttt{\textcolor{myb}{[}[]\textcolor{myb}{]}}, 
        \texttt{\textcolor{myb}{[}["a"]\textcolor{myb}{]}}, 
        \texttt{\textcolor{myb}{[}["ab"], ["a", "b"]\textcolor{myb}{]}}, \\
        \texttt{\textcolor{myb}{[}["a", "bc"], ["ab", "c"]}, \\ 
        \texttt{["a", "b", "c"]\textcolor{myb}{]}} \\
        \textcolor{red}{]}
      \item [$\rhd$] \texttt{table[target.length()] =}  
        \texttt{\textcolor{myb}{[}["a", "bc"], ["ab", "c"]},  
        \texttt{["a", "b", "c"]\textcolor{myb}{]}} \\
        \textcolor{red}{]}
      \item[$\blacktriangleright$] $f($\texttt{target, pieces}$)$ \texttt{=} 
        \texttt{\textcolor{myb}{[}["a", "bc"], ["ab", "c"]},  
        \texttt{["a", "b", "c"]\textcolor{myb}{]}} \\
        \textcolor{red}{]}


 
    \end{itemize}
     
  \end{EExample}


  \paragraph{Complexité dans le temps}
  La fonctions possède deux boucles imbriquées de complexitée proportionnelle à
  \texttt{target.lenght()}. En effet,on suppose que \texttt{pieces} est une partitions de \texttt{target}   
  tel que :
  \[ \texttt{target.lenght() = pieces.lenght}  \]
  Dans la seconde boucle, on vérifie si une pièce, disons de longueur $k$, 
  est le début d'une sous-chaîne. En supposant que $k$ est de longueur 1, cette opération 
  est à temps constant. Autrement, elle dépendrait de la longueur de $k$.


  Finalement, pour chaque combinaison existante à la position $i$ dans \texttt{table}, 
  la fonction tente de l'étendre en ajoutant une nouvelle \texttt{piece} valide. 
  Cette opération de génération de combinaison est dépendante du nombre de
  combinaisons précédentes $C_i$, qui peuvent croître de manière significative 
  à chaque étape. Ainsi, l'opération de génération de combinaison a une 
  complexité temporelle de $O(n \cdot C)$, où $n$ est la longueur de la 
  cible et $C$ est le nombre total de combinaisons uniques à l'indice $i$. 
  Si chaque \texttt{piece} peut être utilisée une seule fois et correspond 
  à un caractère unique dans \texttt{target}, le nombre de combinaisons $C_i$ 
  à chaque indice reste constant, simplifiant la complexité globale de la fonction à $O(n^2)$.
  Cependant, dans des cas où des caractères se répètent et peuvent être combinés de
  différentes manières, $C$ peut croître exponentiellement, augmentant ainsi l
  a complexité temporelle.


  \paragraph{Complexité dans l'espace}
  La complexité en espace totale est la somme de la mémoire requise pour le tableau 
  \texttt{table} et les combinaisons qu'il contient. Dans le pire cas, avec un grand nombre de 
  combinaisons, elle peut devenir exponentielle, notée \( O(2^n) \). Toutefois, si chaque 
  \texttt{piece} est unique et ne peut être utilisée qu'une seule fois, la complexité est 
  réduite à \( O(n^2) \), car chaque indice contiendrait au plus une combinaison de \texttt{n} 
  caractères, et il y a \texttt{n+1} indices.





  %Retourne une liste de listes de ch. char. 
  %Prend une chain char. et un Liste de ch. char. 

  % Crée un tableau de la taille de la ch. char target 
  % Chaque élément du tableau table possède maintenant ArrayList
  % ajoute au début du tableau table une nouvelle ArrayList









\end{multicols*}
\end{document}
